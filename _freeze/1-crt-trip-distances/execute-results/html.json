{
  "hash": "ef6d6d7f18ea881bc34ec7c81ab1bf62",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: Explore Distribution of CRT Travel Distances\nsubtitle: Using UTA On-Board Survey Data and Skim Matrices\ndescription: Lorem Ipsum\nauthor:\n - name: Pukar Bhandari\n   email: pukar.bhandari@wfrc.utah.gov\n   affiliation:\n     - name: Wasatch Front Regional Council\n       url: \"https://wfrc.utah.gov/\"\ndate: \"2025-11-14\"\n---\n\n# Setup Environment\n\nThis section establishes the Python environment with all required libraries for geospatial analysis and data processing. Beyond standard data manipulation tools, we'll need geopandas for spatial operations and regular expressions for parsing the non-transit links file. The helper functions defined here will be used throughout the analysis for spatial matching and file parsing.\n\n## Install Libraries\n\n```python\n!conda install -c conda-forge numpy pandas geopandas matplotlib seaborn shapely requests pathlib\n```\n\n## Import Libraries\n\n::: {#c7970b1a .cell execution_count=1}\n``` {.python .cell-code}\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport matplotlib.dates as mdates\nfrom matplotlib.ticker import FuncFormatter\nimport seaborn as sns\nimport geopandas as gpd\nfrom pathlib import Path\nimport glob\nfrom dbfread import DBF\nimport re\nimport os\nimport requests\nimport io\n\nimport openmatrix as omx\nimport subprocess\n```\n:::\n\n\n## Environment Variables\n\n::: {#a8b13636 .cell execution_count=2}\n``` {.python .cell-code}\nPROJECT_CRS = \"EPSG:3566\"  # NAD83 / Utah North (ftUS)\n```\n:::\n\n\n## Helper Functions\n\n::: {#6f5c0115 .cell execution_count=3}\n``` {.python .cell-code}\ndef fetch_github(\n    url: str,\n    mode: str = \"private\",\n    token_env_var: str = \"GITHUB_TOKEN\"\n) -> requests.Response:\n    \"\"\"\n    Fetch content from GitHub repositories.\n\n    Args:\n        url: GitHub raw URL (e.g., https://raw.githubusercontent.com/...)\n        mode: \"public\" for public repos, \"private\" for private repos requiring authentication\n        token_env_var: Name of environment variable containing GitHub token (default: GITHUB_TOKEN)\n\n    Returns:\n        requests.Response object\n\n    Raises:\n        ValueError: If token is missing for private mode or invalid mode\n        requests.HTTPError: If request fails\n    \"\"\"\n    # Validate mode\n    if mode not in [\"public\", \"private\"]:\n        raise ValueError(f\"mode must be 'public' or 'private', got '{mode}'\")\n\n    if mode == \"public\":\n        response = requests.get(url, timeout=30)\n    else:\n        token = os.getenv(token_env_var)\n        if not token:\n            raise ValueError(\n                f\"GitHub token not found in environment variable '{token_env_var}'. \"\n                f\"Check your .env file has: {token_env_var}=your_token_here\"\n            )\n\n        headers = {\n            'Authorization': f'token {token}',\n            'Accept': 'application/vnd.github.v3.raw'\n        }\n        response = requests.get(url, headers=headers, timeout=30)\n\n    response.raise_for_status()\n    return response\n```\n:::\n\n\n# Load Data\n\n## TAZ Shapefile\n\n::: {#6c8c8c0b .cell execution_count=4}\n``` {.python .cell-code}\ngdf_taz_v10 = gpd.read_file(\n    r\"_data/TAZ/WFv910_TAZ.shp\"\n).to_crs(PROJECT_CRS)\n```\n:::\n\n\n::: {#e1fec5a6 .cell execution_count=5}\n``` {.python .cell-code}\ngdf_taz_v10.explore()\n```\n:::\n\n\n## Processed On-Board Survey Data\n\nThis dataset is the output from the [\"previous step\"](https://github.com/WFRCAnalytics/DATA-OBS-Prep-For-TDM), which contains all the calculated access and egress distances and times.\n\n::: {#56ab214d .cell execution_count=6}\n``` {.python .cell-code}\n# Read Linked UTA On-Board Survey Data directly from GitHub repo\nresponse = fetch_github(\n    \"https://raw.githubusercontent.com/WFRCAnalytics/DATA-OBS-Prep-For-TDM/refs/heads/main/_output/UTA_OBS_2024_Linked_FactorAdjusted.csv\",\n    mode = \"private\"\n)\n\ndf_obs_linked = pd.read_csv(io.StringIO(response.text))\n\n# Filter only the Weekday trips\ndf_obs_linked = df_obs_linked[df_obs_linked[\"DATE_TYPE\"] == \"Weekday\"]\ndf_obs_linked\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nC:\\Users\\Pukar.Bhandari\\AppData\\Local\\Temp\\ipykernel_8512\\3049727246.py:7: DtypeWarning:\n\nColumns (8,24,32,37,54,132,137,174,287) have mixed types. Specify dtype option on import or set low_memory=False.\n\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=5}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>ID</th>\n      <th>DATE_COMPLETED</th>\n      <th>DATE_TYPE</th>\n      <th>ROUTE_DIRECTION_Code</th>\n      <th>ROUTE_DIRECTION</th>\n      <th>ROUTE_DIRECTION_Other</th>\n      <th>HOME_ADDRESS_CITY</th>\n      <th>HOME_ADDRESS_STATE</th>\n      <th>HOME_ADDRESS_ZIP</th>\n      <th>HOME_ADDRESS_LAT</th>\n      <th>...</th>\n      <th>a_Stop_lat</th>\n      <th>a_Stop_lon</th>\n      <th>p_Stop_N</th>\n      <th>a_Stop_N</th>\n      <th>access_dist</th>\n      <th>access_time</th>\n      <th>egress_dist</th>\n      <th>egress_time</th>\n      <th>Adj_Factor</th>\n      <th>trip_weight</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>5948</td>\n      <td>2024-02-27</td>\n      <td>Weekday</td>\n      <td>UTA_1_2_00</td>\n      <td>2 200 SOUTH - TO U HOSPITAL</td>\n      <td>NaN</td>\n      <td>Clearfield</td>\n      <td>UT</td>\n      <td>84015</td>\n      <td>41.119565</td>\n      <td>...</td>\n      <td>40.769221</td>\n      <td>-111.898663</td>\n      <td>27702.0</td>\n      <td>25493.0</td>\n      <td>0.37</td>\n      <td>8.79</td>\n      <td>0.68</td>\n      <td>16.27</td>\n      <td>1.195057</td>\n      <td>7.988529</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>6067</td>\n      <td>2024-02-27</td>\n      <td>Weekday</td>\n      <td>UTA_1_47_00</td>\n      <td>47 4700 SOUTH - TO W VALLEY CTL</td>\n      <td>NaN</td>\n      <td>West Valley City</td>\n      <td>UT</td>\n      <td>84119</td>\n      <td>40.689590</td>\n      <td>...</td>\n      <td>40.660941</td>\n      <td>-111.899443</td>\n      <td>23195.0</td>\n      <td>23685.0</td>\n      <td>0.56</td>\n      <td>13.53</td>\n      <td>0.24</td>\n      <td>5.70</td>\n      <td>1.407280</td>\n      <td>4.420834</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>6073</td>\n      <td>2024-02-28</td>\n      <td>Weekday</td>\n      <td>UTA_1_750_01</td>\n      <td>FRONTRUNNER 750 - SOUTHBOUND</td>\n      <td>NaN</td>\n      <td>Ogden</td>\n      <td>UT</td>\n      <td>84401</td>\n      <td>41.236749</td>\n      <td>...</td>\n      <td>40.659758</td>\n      <td>-111.896432</td>\n      <td>10042.0</td>\n      <td>10016.0</td>\n      <td>4.17</td>\n      <td>8.22</td>\n      <td>1.37</td>\n      <td>3.29</td>\n      <td>1.192511</td>\n      <td>5.413118</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>6077</td>\n      <td>2024-02-28</td>\n      <td>Weekday</td>\n      <td>UTA_1_47_00</td>\n      <td>47 4700 SOUTH - TO W VALLEY CTL</td>\n      <td>NaN</td>\n      <td>West Valley City</td>\n      <td>UT</td>\n      <td>84119</td>\n      <td>40.669687</td>\n      <td>...</td>\n      <td>40.681907</td>\n      <td>-112.024041</td>\n      <td>22922.0</td>\n      <td>22421.0</td>\n      <td>0.25</td>\n      <td>6.00</td>\n      <td>0.49</td>\n      <td>11.88</td>\n      <td>1.407280</td>\n      <td>10.487378</td>\n    </tr>\n    <tr>\n      <th>5</th>\n      <td>6078</td>\n      <td>2024-02-28</td>\n      <td>Weekday</td>\n      <td>UTA_1_220_00</td>\n      <td>220 HIGHLAND DRIVE / 1300 EAST - TO SANDY</td>\n      <td>NaN</td>\n      <td>Salt Lake City</td>\n      <td>UT</td>\n      <td>84101</td>\n      <td>40.765122</td>\n      <td>...</td>\n      <td>40.687097</td>\n      <td>-111.866122</td>\n      <td>15115.0</td>\n      <td>24517.0</td>\n      <td>0.27</td>\n      <td>6.51</td>\n      <td>0.19</td>\n      <td>4.55</td>\n      <td>1.407280</td>\n      <td>3.287619</td>\n    </tr>\n    <tr>\n      <th>...</th>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n    </tr>\n    <tr>\n      <th>13790</th>\n      <td>30339</td>\n      <td>2024-04-26</td>\n      <td>Weekday</td>\n      <td>UTA_1_704_01</td>\n      <td>TRAX GREEN LINE 704 - TO AIRPORT</td>\n      <td>NaN</td>\n      <td>Salt Lake City</td>\n      <td>UT</td>\n      <td>84116</td>\n      <td>40.772420</td>\n      <td>...</td>\n      <td>40.771502</td>\n      <td>-111.914486</td>\n      <td>15101.0</td>\n      <td>15122.0</td>\n      <td>0.31</td>\n      <td>7.53</td>\n      <td>0.17</td>\n      <td>4.07</td>\n      <td>1.405314</td>\n      <td>8.528545</td>\n    </tr>\n    <tr>\n      <th>13791</th>\n      <td>30340</td>\n      <td>2024-04-26</td>\n      <td>Weekday</td>\n      <td>UTA_1_704_00</td>\n      <td>TRAX GREEN LINE 704 - TO WEST VALLEY</td>\n      <td>NaN</td>\n      <td>Salt Lake City</td>\n      <td>UT</td>\n      <td>84116</td>\n      <td>40.771361</td>\n      <td>...</td>\n      <td>40.750058</td>\n      <td>-111.896818</td>\n      <td>15122.0</td>\n      <td>15109.0</td>\n      <td>0.46</td>\n      <td>11.00</td>\n      <td>1.21</td>\n      <td>29.10</td>\n      <td>1.405314</td>\n      <td>16.406476</td>\n    </tr>\n    <tr>\n      <th>13792</th>\n      <td>30341</td>\n      <td>2024-04-26</td>\n      <td>Weekday</td>\n      <td>UTA_1_704_00</td>\n      <td>TRAX GREEN LINE 704 - TO WEST VALLEY</td>\n      <td>NaN</td>\n      <td>Salt Lake City</td>\n      <td>UT</td>\n      <td>84116</td>\n      <td>40.773232</td>\n      <td>...</td>\n      <td>40.725345</td>\n      <td>-111.877499</td>\n      <td>15122.0</td>\n      <td>24968.0</td>\n      <td>0.17</td>\n      <td>4.07</td>\n      <td>0.86</td>\n      <td>20.68</td>\n      <td>1.405314</td>\n      <td>8.203238</td>\n    </tr>\n    <tr>\n      <th>13793</th>\n      <td>1000002</td>\n      <td>2024-02-29</td>\n      <td>Weekday</td>\n      <td>UTA_1_701_00</td>\n      <td>TRAX BLUE LINE 701 - TO DRAPER</td>\n      <td>NaN</td>\n      <td>Salt Lake City</td>\n      <td>UT</td>\n      <td>84111</td>\n      <td>40.751607</td>\n      <td>...</td>\n      <td>40.674859</td>\n      <td>-111.943134</td>\n      <td>15123.0</td>\n      <td>23342.0</td>\n      <td>0.33</td>\n      <td>7.95</td>\n      <td>0.29</td>\n      <td>7.02</td>\n      <td>0.893041</td>\n      <td>4.139760</td>\n    </tr>\n    <tr>\n      <th>13794</th>\n      <td>1000004</td>\n      <td>2024-02-29</td>\n      <td>Weekday</td>\n      <td>UTA_1_701_00</td>\n      <td>TRAX BLUE LINE 701 - TO DRAPER</td>\n      <td>NaN</td>\n      <td>Salt Lake City</td>\n      <td>UT</td>\n      <td>84109</td>\n      <td>40.722068</td>\n      <td>...</td>\n      <td>40.525496</td>\n      <td>-111.858805</td>\n      <td>25663.0</td>\n      <td>15041.0</td>\n      <td>0.79</td>\n      <td>18.85</td>\n      <td>0.19</td>\n      <td>4.44</td>\n      <td>1.405314</td>\n      <td>4.676107</td>\n    </tr>\n  </tbody>\n</table>\n<p>12020 rows × 309 columns</p>\n</div>\n```\n:::\n:::\n\n\n## Transit Network Nodes\n\nThe transit network comes from the travel demand model's master network. This network contains all possible locations where transit vehicles can stop. We need to match survey stop locations to these official network nodes to calculate accurate walk distances from the model's non-transit links.\n\n### Load MasterNetwork Nodes\n\nThe MasterNetwork contains all nodes in the regional transportation network - roadway intersections, transit stops, park-and-ride locations, etc. We load the complete network first, then filter to just transit-related nodes.\n\n::: {#3a23a2e8 .cell execution_count=7}\n``` {.python .cell-code}\n# Load all nodes from MasterNetwork\ngdf_masternet_nodes = gpd.read_file(\n    # Source: \\\\ModelAce\\ModelAce-E\\1 - TDM\\1 - Official Release (full run)\\v9x\\v9.1\\v9.1.1\\WF-TDM-v9.1.1 - revised-se\\Scenarios\\OY_2023\\0_InputProcessing\\ScenarioNet\n    r\"_data/ScenarioNet/WFv911-revised-se_OY_2023 - Node.shp\"\n).to_crs(PROJECT_CRS)\n```\n:::\n\n\n::: {#8304a1a3 .cell execution_count=8}\n``` {.python .cell-code}\ngdf_masternet_nodes.explore()\n```\n:::\n\n\n### Filter to Transit Stop Nodes\n\nNot all nodes in the MasterNetwork are transit stops. The c_StopsAllModes.dbf file contains a list of node IDs that represent actual transit stops. We filter the network to only these nodes, giving us the set of locations where we can calculate walk access/egress distances.\n\n\n\n::: {#6e8863a7 .cell execution_count=10}\n``` {.python .cell-code}\n# Read all mode-specific stop files and combine into one dataframe\ndf_stop_nodes_list = pd.concat(\n    # Source: \"\\\\ModelAce\\ModelAce-E\\1 - TDM\\1 - Official Release (full run)\\v9x\\v9.1\\v9.1.1\\WF-TDM-v9.1.1 - revised-se\\Scenarios\\OY_2023\\0_InputProcessing\\\"\n    [pd.DataFrame(DBF(file)).assign(MODE=int(re.search(r'Mode(\\d+)', file).group(1)))\n     for file in glob.glob(r'_data/Stops/c_StopsMode[4-9].dbf')],\n    ignore_index=True\n)\n\ndf_stop_nodes_list['N'] = df_stop_nodes_list['N'].astype('Int64')\n```\n:::\n\n\n::: {#f8f10673 .cell execution_count=11}\n``` {.python .cell-code}\ndf_stop_nodes_list\n```\n\n::: {.cell-output .cell-output-display execution_count=8}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>N</th>\n      <th>X</th>\n      <th>Y</th>\n      <th>MODE</th>\n      <th>ROUTE</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>28936</td>\n      <td>418003.0308</td>\n      <td>4565514.975</td>\n      <td>4</td>\n      <td>NaN</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>28909</td>\n      <td>417986.8035</td>\n      <td>4565124.024</td>\n      <td>4</td>\n      <td>NaN</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>28888</td>\n      <td>417981.0000</td>\n      <td>4564879.000</td>\n      <td>4</td>\n      <td>NaN</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>28870</td>\n      <td>417977.5915</td>\n      <td>4564656.512</td>\n      <td>4</td>\n      <td>NaN</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>28851</td>\n      <td>417964.0000</td>\n      <td>4564428.000</td>\n      <td>4</td>\n      <td>NaN</td>\n    </tr>\n    <tr>\n      <th>...</th>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n    </tr>\n    <tr>\n      <th>1900</th>\n      <td>67371</td>\n      <td>442160.3193</td>\n      <td>4458319.613</td>\n      <td>9</td>\n      <td>NaN</td>\n    </tr>\n    <tr>\n      <th>1901</th>\n      <td>67380</td>\n      <td>440904.0313</td>\n      <td>4458351.939</td>\n      <td>9</td>\n      <td>NaN</td>\n    </tr>\n    <tr>\n      <th>1902</th>\n      <td>67383</td>\n      <td>440091.0000</td>\n      <td>4458361.924</td>\n      <td>9</td>\n      <td>NaN</td>\n    </tr>\n    <tr>\n      <th>1903</th>\n      <td>67421</td>\n      <td>439380.5328</td>\n      <td>4458629.972</td>\n      <td>9</td>\n      <td>NaN</td>\n    </tr>\n    <tr>\n      <th>1904</th>\n      <td>50029</td>\n      <td>438356.2813</td>\n      <td>4459074.432</td>\n      <td>9</td>\n      <td>NaN</td>\n    </tr>\n  </tbody>\n</table>\n<p>1905 rows × 5 columns</p>\n</div>\n```\n:::\n:::\n\n\n::: {#3bdc5c78 .cell execution_count=12}\n``` {.python .cell-code}\n# Join to get geometry for each N-MODE combination\ndf_stop_nodes = gdf_masternet_nodes[['N', 'geometry']].merge(\n    df_stop_nodes_list[['N', 'MODE']],\n    on='N',\n    how='inner',\n    validate=\"1:m\" # multiple stops (by mode) can have same stop id and geometry\n)\n```\n:::\n\n\n::: {#8152ce7c .cell execution_count=13}\n``` {.python .cell-code}\ndf_stop_nodes.explore()\n```\n:::\n\n\n## Transit Trip Matrix\n\n### Convert Matrix Format using `_ConvertMatToOmx.s`.\n\nThis only needs to run once.\n\n::: {.callout-tip}\nSkim matrices were copied from `\\\\ModelAce\\ModelAce-E\\1 - TDM\\1 - Official Release (full run)\\v9x\\v9.1\\v9.1.1\\WF-TDM-v9.1.1 - revised-se\\Scenarios\\OY_2023\\4_ModeChoice\\1a_Skims` (For this exact run, skim matrices were used from modified NTL runs.)\n:::\n\n::: {#8f51af77 .cell execution_count=14}\n``` {.python .cell-code}\n# Define output files to check\noutput_files = [\n    \"_data/Skims/omx/skm_d8_Ok.omx\",\n    \"_data/Skims/omx/skm_d8_Pk.omx\",\n    \"_data/Skims/omx/skm_w8_flag_Ok.omx\",\n    \"_data/Skims/omx/skm_w8_flag_Pk.omx\",\n    \"_data/Skims/omx/skm_w8_Ok.omx\",\n    \"_data/Skims/omx/skm_w8_Pk.omx\",\n]\n\n# Check if all output files exist\nif not all(Path(f).exists() for f in output_files):\n    print(\"Converting matrices to OMX format...\")\n    subprocess.run(\n        [r\"C:\\Program Files\\Citilabs\\CubeVoyager\\Voyager.exe\",\n         r\"_data\\_ConvertMatToOmx.s\"],\n        check=True\n    )\n    print(\"Conversion complete!\")\nelse:\n    print(\"OMX files already exist, skipping conversion.\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nOMX files already exist, skipping conversion.\n```\n:::\n:::\n\n\n## Read Matrices\n\n::: {#5f622289 .cell execution_count=15}\n``` {.python .cell-code}\n# Read Matrices as DataFrames\nomx_w8_pk = pd.DataFrame(omx.open_file(r\"_data\\Skims\\omx\\skm_w8_Pk.omx\")['D8'])\nomx_w8_ok = pd.DataFrame(omx.open_file(r\"_data\\Skims\\omx\\skm_w8_Ok.omx\")['D8'])\nomx_d8_pk = pd.DataFrame(omx.open_file(r\"_data\\Skims\\omx\\skm_d8_Pk.omx\")['D8'])\nomx_d8_ok = pd.DataFrame(omx.open_file(r\"_data\\Skims\\omx\\skm_d8_Ok.omx\")['D8'])\n```\n:::\n\n\n# Process Matrix\n\n::: {#020e47ae .cell execution_count=16}\n``` {.python .cell-code}\n# Create Peak composite matrix - max of walk and drive in both directions\nskim_pk = np.maximum.reduce([\n    omx_w8_pk.values,           # Walk access (normal direction)\n    omx_w8_pk.values.T,         # Walk egress (reversed direction)\n    omx_d8_pk.values,           # Drive access (normal direction)\n    omx_d8_pk.values.T          # Drive egress (reversed direction)\n])\n\nskim_pk = pd.DataFrame(skim_pk, index=omx_w8_pk.index, columns=omx_w8_pk.columns)\n```\n:::\n\n\n::: {#a2402c54 .cell execution_count=17}\n``` {.python .cell-code}\n# Create Off-peak composite matrix - max of walk and drive in both directions\nskim_ok = np.maximum.reduce([\n    omx_w8_ok.values,           # Walk access (normal direction)\n    omx_w8_ok.values.T,         # Walk egress (reversed direction)\n    omx_d8_ok.values,           # Drive access (normal direction)\n    omx_d8_ok.values.T          # Drive egress (reversed direction)\n])\nskim_ok = pd.DataFrame(skim_ok, index=omx_w8_ok.index, columns=omx_w8_ok.columns)\n```\n:::\n\n\n# Process Data\n\n## Assign which matrix to process for each row\n\n::: {#60a6cfec .cell execution_count=18}\n``` {.python .cell-code}\n# Create uses_crt column once\ndf_obs_linked['uses_crt'] = df_obs_linked[['FirstMode', 'SecndMode', 'ThirdMode', 'FourthMode', 'FifthMode', 'LastMode']].eq('CRT').any(axis=1)\n```\n:::\n\n\n## Calculate CRT Distances\n\n::: {#97647963 .cell execution_count=19}\n``` {.python .cell-code}\n# Calculate CRT Distances - simplified with composite matrices\ndf_obs_linked['valid_crt_mask'] = (\n    df_obs_linked['uses_crt'] &\n    df_obs_linked['p_TAZID'].notna() &\n    df_obs_linked['a_TAZID'].notna() &\n    df_obs_linked['trip_weight'].notna()  # Add trip_weight check here\n)\n```\n:::\n\n\n::: {#51fcf63a .cell execution_count=20}\n``` {.python .cell-code}\n# Initialize column\ndf_obs_linked['dist_CRT'] = np.nan\n\n# Process peak periods\npk_mask = df_obs_linked['valid_crt_mask'] & df_obs_linked['Period'].isin(['AM', 'PM'])\nif pk_mask.any():\n    row_indices = (df_obs_linked.loc[pk_mask, 'p_TAZID'] - 1).astype(int)\n    col_indices = (df_obs_linked.loc[pk_mask, 'a_TAZID'] - 1).astype(int)\n    df_obs_linked.loc[pk_mask, 'dist_CRT'] = skim_pk.values[row_indices, col_indices]\n\n# Process off-peak periods\nok_mask = df_obs_linked['valid_crt_mask'] & df_obs_linked['Period'].isin(['MD', 'EV'])\nif ok_mask.any():\n    row_indices = (df_obs_linked.loc[ok_mask, 'p_TAZID'] - 1).astype(int)\n    col_indices = (df_obs_linked.loc[ok_mask, 'a_TAZID'] - 1).astype(int)\n    df_obs_linked.loc[ok_mask, 'dist_CRT'] = skim_ok.values[row_indices, col_indices]\n\ndf_obs_linked[['dist_CRT']]\n```\n\n::: {.cell-output .cell-output-display execution_count=16}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>dist_CRT</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>NaN</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>NaN</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>44.26</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>NaN</td>\n    </tr>\n    <tr>\n      <th>5</th>\n      <td>NaN</td>\n    </tr>\n    <tr>\n      <th>...</th>\n      <td>...</td>\n    </tr>\n    <tr>\n      <th>13790</th>\n      <td>NaN</td>\n    </tr>\n    <tr>\n      <th>13791</th>\n      <td>NaN</td>\n    </tr>\n    <tr>\n      <th>13792</th>\n      <td>NaN</td>\n    </tr>\n    <tr>\n      <th>13793</th>\n      <td>NaN</td>\n    </tr>\n    <tr>\n      <th>13794</th>\n      <td>NaN</td>\n    </tr>\n  </tbody>\n</table>\n<p>12020 rows × 1 columns</p>\n</div>\n```\n:::\n:::\n\n\n::: {#6db57254 .cell execution_count=21}\n``` {.python .cell-code}\ncrt_dist_count = (\n    df_obs_linked[['ID', 'PK_OK', 'Ac_Mode2_Model', 'Eg_Mode2_Model', 'p_TAZID', 'a_TAZID', 'dist_CRT']]\n    # .replace(0, np.nan)\n    .dropna()\n    .sort_values('dist_CRT')\n)\n\ncrt_dist_count\n```\n\n::: {.cell-output .cell-output-display execution_count=17}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>ID</th>\n      <th>PK_OK</th>\n      <th>Ac_Mode2_Model</th>\n      <th>Eg_Mode2_Model</th>\n      <th>p_TAZID</th>\n      <th>a_TAZID</th>\n      <th>dist_CRT</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>12364</th>\n      <td>28075</td>\n      <td>OK</td>\n      <td>Drive</td>\n      <td>Walk</td>\n      <td>883.0</td>\n      <td>1036.0</td>\n      <td>0.00</td>\n    </tr>\n    <tr>\n      <th>11142</th>\n      <td>25998</td>\n      <td>OK</td>\n      <td>Drive</td>\n      <td>Drive</td>\n      <td>264.0</td>\n      <td>2701.0</td>\n      <td>0.00</td>\n    </tr>\n    <tr>\n      <th>13229</th>\n      <td>29441</td>\n      <td>PK</td>\n      <td>Walk</td>\n      <td>Drive</td>\n      <td>356.0</td>\n      <td>541.0</td>\n      <td>0.00</td>\n    </tr>\n    <tr>\n      <th>712</th>\n      <td>7675</td>\n      <td>PK</td>\n      <td>Drive</td>\n      <td>Walk</td>\n      <td>1923.0</td>\n      <td>541.0</td>\n      <td>0.00</td>\n    </tr>\n    <tr>\n      <th>4355</th>\n      <td>14541</td>\n      <td>PK</td>\n      <td>Drive</td>\n      <td>Walk</td>\n      <td>743.0</td>\n      <td>1007.0</td>\n      <td>0.00</td>\n    </tr>\n    <tr>\n      <th>...</th>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n    </tr>\n    <tr>\n      <th>621</th>\n      <td>7534</td>\n      <td>PK</td>\n      <td>Drive</td>\n      <td>Drive</td>\n      <td>413.0</td>\n      <td>2968.0</td>\n      <td>81.08</td>\n    </tr>\n    <tr>\n      <th>2338</th>\n      <td>10844</td>\n      <td>PK</td>\n      <td>Drive</td>\n      <td>Drive</td>\n      <td>377.0</td>\n      <td>3010.0</td>\n      <td>81.08</td>\n    </tr>\n    <tr>\n      <th>10396</th>\n      <td>24688</td>\n      <td>PK</td>\n      <td>Drive</td>\n      <td>Walk</td>\n      <td>2990.0</td>\n      <td>437.0</td>\n      <td>81.08</td>\n    </tr>\n    <tr>\n      <th>445</th>\n      <td>7112</td>\n      <td>PK</td>\n      <td>Drive</td>\n      <td>Walk</td>\n      <td>249.0</td>\n      <td>2939.0</td>\n      <td>81.08</td>\n    </tr>\n    <tr>\n      <th>673</th>\n      <td>7617</td>\n      <td>OK</td>\n      <td>Drive</td>\n      <td>Walk</td>\n      <td>338.0</td>\n      <td>2939.0</td>\n      <td>81.08</td>\n    </tr>\n  </tbody>\n</table>\n<p>2303 rows × 7 columns</p>\n</div>\n```\n:::\n:::\n\n\n::: {#44913af5 .cell execution_count=22}\n``` {.python .cell-code}\n(df_obs_linked[df_obs_linked['dist_CRT'] == 0]['trip_weight'].sum() / df_obs_linked['trip_weight'].sum()) * 100\n```\n\n::: {.cell-output .cell-output-display execution_count=18}\n```\n0.7107702342099061\n```\n:::\n:::\n\n\n::: {#93774766 .cell execution_count=23}\n``` {.python .cell-code}\n# Set seaborn style\nsns.set_style(\"whitegrid\")\nsns.set_context(\"notebook\", font_scale=1.1)\n\nplt.figure(figsize=(10, 6))\n\n# Filter relevant data\ndf_valid = df_obs_linked[\n    (df_obs_linked['dist_CRT'].notna()) #& # filter out NaNs and\n    # (df_obs_linked['dist_CRT'] > 0) # only non-zero distances\n]\n\n# Create histogram with KDE\nax = sns.histplot(\n    data=df_valid,\n    x='dist_CRT',\n    weights=\"trip_weight\",\n    bins=(lambda x: range(0, int(df_valid['dist_CRT'].max()) + x, x))(5),\n    kde=True,\n    color='steelblue',\n    edgecolor='white',\n    linewidth=0.5,\n    alpha=0.7\n)\n\n# Add 95th percentile line using sorted cumulative weights\ndf_sorted = df_valid.sort_values('dist_CRT')\ncumsum = df_sorted['trip_weight'].cumsum()\npct95 = df_sorted.loc[cumsum >= cumsum.iloc[-1] * 0.95, 'dist_CRT'].iloc[0]\n\nplt.axvline(pct95, color='red', linestyle='--', linewidth=2, label=f'95th percentile: {pct95:.1f} mi')\nplt.legend()\n\n# Add grid for better readability\nplt.grid(axis='y', alpha=0.3, linestyle='--')\n\n# Customize\nplt.title('Distribution of CRT Travel Distances', fontsize=16, fontweight='bold', pad=20)\nplt.xlabel('Distance (miles)', fontsize=12)\nplt.ylabel('Frequency', fontsize=12)\n\nsns.despine()\nplt.tight_layout()\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](1-crt-trip-distances_files/figure-html/cell-24-output-1.png){width=940 height=557}\n:::\n:::\n\n\n## Assign CRT Class for each bins\n\n::: {#4e8c42a3 .cell execution_count=24}\n``` {.python .cell-code}\n# Create CRT distance classes using pd.cut\ndf_obs_linked['class_CRT'] = pd.cut(\n    df_obs_linked['dist_CRT'],\n    bins=[0, 10, 20, 30, 40, 50, 60, 70, 80, np.inf],\n    labels=['CRT_00', 'CRT_01', 'CRT_02', 'CRT_03', 'CRT_04', 'CRT_05', 'CRT_06', 'CRT_07', 'CRT_08'],\n    right=True,  # intervals are (a, b] - include right edge\n    include_lowest=False  # exclude 0 from first bin\n)\n\n# Check the distribution\ndf_obs_linked['class_CRT'].value_counts().sort_index()\n```\n\n::: {.cell-output .cell-output-display execution_count=20}\n```\nclass_CRT\nCRT_00    158\nCRT_01    316\nCRT_02    478\nCRT_03    751\nCRT_04    361\nCRT_05     55\nCRT_06     40\nCRT_07     19\nCRT_08      9\nName: count, dtype: int64\n```\n:::\n:::\n\n\n::: {#1037529c .cell execution_count=25}\n``` {.python .cell-code}\ndf_obs_linked.filter(regex='(_LAT|_LONG)$').columns\n```\n\n::: {.cell-output .cell-output-display execution_count=21}\n```\nIndex(['HOME_ADDRESS_LAT', 'HOME_ADDRESS_LONG', 'ORIGIN_ADDRESS_LAT',\n       'ORIGIN_ADDRESS_LONG', 'DESTIN_ADDRESS_LAT', 'DESTIN_ADDRESS_LONG',\n       'STOP_ON_LAT', 'STOP_ON_LONG', 'STOP_OFF_LAT', 'STOP_OFF_LONG',\n       'PREV_TRAN_1_ON_BUS_LAT', 'PREV_TRAN_1_ON_BUS_LONG',\n       'PREV_TRAN_1_OFF_BUS_LAT', 'PREV_TRAN_1_OFF_BUS_LONG',\n       'PREV_TRAN_2_ON_BUS_LAT', 'PREV_TRAN_2_ON_BUS_LONG',\n       'PREV_TRAN_2_OFF_BUS_LAT', 'PREV_TRAN_2_OFF_BUS_LONG',\n       'PREV_TRAN_3_ON_BUS_LAT', 'PREV_TRAN_3_ON_BUS_LONG',\n       'PREV_TRAN_3_OFF_BUS_LAT', 'PREV_TRAN_3_OFF_BUS_LONG',\n       'NEXT_TRAN_1_ON_BUS_LAT', 'NEXT_TRAN_1_ON_BUS_LONG',\n       'NEXT_TRAN_1_OFF_BUS_LAT', 'NEXT_TRAN_1_OFF_BUS_LONG',\n       'NEXT_TRAN_2_ON_BUS_LAT', 'NEXT_TRAN_2_ON_BUS_LONG',\n       'NEXT_TRAN_2_OFF_BUS_LAT', 'NEXT_TRAN_2_OFF_BUS_LONG',\n       'NEXT_TRAN_3_ON_BUS_LAT', 'NEXT_TRAN_3_ON_BUS_LONG',\n       'NEXT_TRAN_3_OFF_BUS_LAT', 'NEXT_TRAN_3_OFF_BUS_LONG'],\n      dtype='object')\n```\n:::\n:::\n\n\n::: {#84cd3f2d .cell execution_count=26}\n``` {.python .cell-code}\nimport folium\nfrom folium import Marker, CircleMarker, FeatureGroup, PolyLine\nimport pandas as pd\nimport numpy as np\n\n# ============================================================================\n# COLOR AND STYLE CONFIGURATION\n# ============================================================================\nMODE_STYLES = {\n    1: {'color': '#5b80a3', 'weight': 2},   # MT (Microtransit)\n    4: {'color': '#00508b', 'weight': 3},   # LCL (Local Bus) - UTA Blue\n    5: {'color': '#FF6B35', 'weight': 3},   # COR (Core Bus)\n    6: {'color': '#6fb74d', 'weight': 3},   # EXP (Express Bus)\n    7: {'color': '#ce132d', 'weight': 4},   # LRT (Light Rail) - UTA Red\n    8: {'color': '#9c4392', 'weight': 6},   # CRT (Commuter Rail) - UTA Green\n    9: {'color': '#007dbb', 'weight': 5}    # BRT (Bus Rapid Transit)\n}\n\nACCESS_EGRESS_STYLES = {\n    'Walk': {'color': '#898a8d', 'weight': 2},\n    'KNR': {'color': '#FFA500', 'weight': 2},\n    'PNR': {'color': '#FF6B35', 'weight': 2},\n    'Drive': {'color': '#FF6B35', 'weight': 2}\n}\n\nTRANSFER_WALK_STYLE = {'color': '#898a8d', 'weight': 2}\nSNAP_LINE_STYLE = {'color': '#00CED1', 'weight': 2, 'dash_array': '5, 5'}  # Dashed cyan for snap connections\nSURVEYED_TRIP_WEIGHT_MULTIPLIER = 1.5\n\n# ============================================================================\n# SETUP\n# ============================================================================\nRESPONSE_ID = 15514\n\ndf_plot = df_obs_linked[df_obs_linked[\"ID\"] == RESPONSE_ID].iloc[0]\n\n# Determine center\nif pd.notna(df_plot['p_lat']) and pd.notna(df_plot['p_lon']):\n    center_lat, center_lon = df_plot['p_lat'], df_plot['p_lon']\nelif pd.notna(df_plot['a_lat']) and pd.notna(df_plot['a_lon']):\n    center_lat, center_lon = df_plot['a_lat'], df_plot['a_lon']\nelif pd.notna(df_plot['HOME_ADDRESS_LAT']) and pd.notna(df_plot['HOME_ADDRESS_LONG']):\n    center_lat, center_lon = df_plot['HOME_ADDRESS_LAT'], df_plot['HOME_ADDRESS_LONG']\nelse:\n    center_lat, center_lon = 40.7608, -111.8910\n    print(\"Warning: No valid coordinates found, using default center\")\n\nm = folium.Map(location=[center_lat, center_lon], zoom_start=13, tiles='OpenStreetMap')\n\n# Create feature groups\nfg_taz = FeatureGroup(name='Relevant TAZs', show=True)\nfg_all_nodes = FeatureGroup(name='All Transit Network Nodes', show=False)\nfg_stops = FeatureGroup(name='Transit Stops Used', show=True)\nfg_snapped_stops = FeatureGroup(name='Snapped Stop Nodes (from Network)', show=True)\nfg_snap_connections = FeatureGroup(name='Snap Connections', show=True)\nfg_addresses = FeatureGroup(name='Addresses', show=True)\nfg_trip_lines = FeatureGroup(name='Trip Sequence', show=True)\n\n# ============================================================================\n# SHOW RELEVANT TAZs\n# ============================================================================\nif pd.notna(df_plot['p_TAZID']):\n    p_taz = gdf_taz_v10[gdf_taz_v10['TAZID'] == df_plot['p_TAZID']]\n    if len(p_taz) > 0:\n        p_geojson = p_taz.to_crs('EPSG:4326').__geo_interface__\n        folium.GeoJson(\n            p_geojson,\n            style_function=lambda x: {\n                'fillColor': 'darkgreen',\n                'color': 'darkgreen',\n                'weight': 2,\n                'fillOpacity': 0.15\n            },\n            tooltip=f\"Production TAZ: {df_plot['p_TAZID']}\"\n        ).add_to(fg_taz)\n\nif pd.notna(df_plot['a_TAZID']):\n    a_taz = gdf_taz_v10[gdf_taz_v10['TAZID'] == df_plot['a_TAZID']]\n    if len(a_taz) > 0:\n        a_geojson = a_taz.to_crs('EPSG:4326').__geo_interface__\n        folium.GeoJson(\n            a_geojson,\n            style_function=lambda x: {\n                'fillColor': 'darkblue',\n                'color': 'darkblue',\n                'weight': 2,\n                'fillOpacity': 0.15\n            },\n            tooltip=f\"Attraction TAZ: {df_plot['a_TAZID']}\"\n        ).add_to(fg_taz)\n\n# ============================================================================\n# ADD ALL TRANSIT NETWORK NODES (BACKGROUND LAYER)\n# ============================================================================\n# Get unique node geometries (since same node can serve multiple modes)\nunique_nodes = (\n    df_stop_nodes\n    .groupby('N')\n    .agg(\n        geometry=('geometry', 'first'),\n        MODE=('MODE', lambda s: ', '.join(str(m) for m in sorted(s.dropna().unique())))\n    )\n    .reset_index()\n)\n\nunique_nodes_gdf = gpd.GeoDataFrame(unique_nodes, geometry='geometry', crs=df_stop_nodes.crs)\nunique_nodes_gdf_wgs84 = unique_nodes_gdf.to_crs('EPSG:4326')\n\n# Add all nodes as small gray circles\nfor _, node in unique_nodes_gdf_wgs84.iterrows():\n    folium.CircleMarker(\n        location=[node.geometry.y, node.geometry.x],\n        radius=4,\n        color='#444444',\n        fill=True,\n        fillColor='#444444',\n        fillOpacity=0.75,\n        weight=0.75,\n        popup=f\"Node: {node['N']}\\nMode: {node['MODE']}\",\n        tooltip=f\"Node {node['N']}\"\n    ).add_to(fg_all_nodes)\n\n# ============================================================================\n# HELPER FUNCTIONS\n# ============================================================================\ndef get_mode_name(mode_num):\n    mode_names = {\n        1: 'MT (Microtransit)',\n        4: 'LCL (Local)',\n        5: 'COR (Corridor)',\n        6: 'EXP (Express)',\n        7: 'LRT (Light Rail)',\n        8: 'CRT (FrontRunner)',\n        9: 'BRT (Rapid Transit)'\n    }\n    return mode_names.get(mode_num, f'Mode {mode_num}')\n\ndef get_mode_color(mode_num):\n    return MODE_STYLES.get(mode_num, {}).get('color', '#666666')\n\ndef get_mode_weight(mode_num):\n    return MODE_STYLES.get(mode_num, {}).get('weight', 3)\n\ndef add_line_segment(coords_list, color, weight, dash_array, label, popup_text, feature_group):\n    valid_coords = []\n    for coord in coords_list:\n        if coord is not None and len(coord) == 2:\n            lat, lon = coord\n            if pd.notna(lat) and pd.notna(lon):\n                valid_coords.append([lat, lon])\n\n    if len(valid_coords) >= 2:\n        folium.PolyLine(\n            locations=valid_coords,\n            color=color,\n            weight=weight,\n            opacity=0.8,\n            dash_array=dash_array,\n            popup=popup_text,\n            tooltip=label\n        ).add_to(feature_group)\n        return True\n    return False\n\ndef add_stop_marker(lat, lon, label, mode_num, feature_group):\n    if pd.notna(lat) and pd.notna(lon):\n        folium.CircleMarker(\n            location=[lat, lon],\n            radius=6,\n            color=get_mode_color(mode_num),\n            fill=True,\n            fillColor=get_mode_color(mode_num),\n            fillOpacity=0.9,\n            popup=label,\n            tooltip=label\n        ).add_to(feature_group)\n\n# ============================================================================\n# BUILD TRIP SEQUENCE\n# ============================================================================\nis_pa = df_plot['PA_AP'] == 'PA'\ntrip_sequence = []\n\nif is_pa:\n    segments = [\n        ('PREV_TRAN_1', 'Modefrom1', 'Transfer 1 (from origin)'),\n        ('PREV_TRAN_2', 'Modefrom2', 'Transfer 2 (from origin)'),\n        ('PREV_TRAN_3', 'Modefrom3', 'Transfer 3 (from origin)'),\n        ('STOP', 'Mode_Fin', 'SURVEYED TRIP'),\n        ('NEXT_TRAN_1', 'Modeto1', 'Transfer 1 (to destination)'),\n        ('NEXT_TRAN_2', 'Modeto2', 'Transfer 2 (to destination)'),\n        ('NEXT_TRAN_3', 'Modeto3', 'Transfer 3 (to destination)'),\n    ]\nelse:\n    segments = [\n        ('NEXT_TRAN_3', 'Modeto3', 'Transfer 3'),\n        ('NEXT_TRAN_2', 'Modeto2', 'Transfer 2'),\n        ('NEXT_TRAN_1', 'Modeto1', 'Transfer 1'),\n        ('STOP', 'Mode_Fin', 'SURVEYED TRIP'),\n        ('PREV_TRAN_3', 'Modefrom3', 'Transfer 1'),\n        ('PREV_TRAN_2', 'Modefrom2', 'Transfer 2'),\n        ('PREV_TRAN_1', 'Modefrom1', 'Transfer 3'),\n    ]\n\nfor prefix, mode_col, label in segments:\n    if prefix == 'STOP':\n        if is_pa:\n            on_lat = df_plot.get('STOP_ON_LAT')\n            on_lon = df_plot.get('STOP_ON_LONG')\n            off_lat = df_plot.get('STOP_OFF_LAT')\n            off_lon = df_plot.get('STOP_OFF_LONG')\n        else:\n            on_lat = df_plot.get('STOP_OFF_LAT')\n            on_lon = df_plot.get('STOP_OFF_LONG')\n            off_lat = df_plot.get('STOP_ON_LAT')\n            off_lon = df_plot.get('STOP_ON_LONG')\n    else:\n        if is_pa:\n            on_lat = df_plot.get(f'{prefix}_ON_BUS_LAT')\n            on_lon = df_plot.get(f'{prefix}_ON_BUS_LONG')\n            off_lat = df_plot.get(f'{prefix}_OFF_BUS_LAT')\n            off_lon = df_plot.get(f'{prefix}_OFF_BUS_LONG')\n        else:\n            on_lat = df_plot.get(f'{prefix}_OFF_BUS_LAT')\n            on_lon = df_plot.get(f'{prefix}_OFF_BUS_LONG')\n            off_lat = df_plot.get(f'{prefix}_ON_BUS_LAT')\n            off_lon = df_plot.get(f'{prefix}_ON_BUS_LONG')\n\n    mode_num = df_plot.get(mode_col)\n\n    if pd.notna(on_lat) and pd.notna(off_lat) and pd.notna(mode_num):\n        trip_sequence.append({\n            'on_lat': on_lat,\n            'on_lon': on_lon,\n            'off_lat': off_lat,\n            'off_lon': off_lon,\n            'mode_num': int(mode_num),\n            'mode_name': get_mode_name(mode_num),\n            'label': label,\n            'is_current': prefix == 'STOP'\n        })\n\n# ============================================================================\n# ADD SNAPPED NETWORK STOPS\n# ============================================================================\n# Get snapped stop nodes from df_stop_nodes\nsnapped_nodes = []\n\n# Production Stop (Access - where trip starts from network perspective)\nif pd.notna(df_plot['p_Stop_N']):\n    p_stop_matches = df_stop_nodes[df_stop_nodes['N'] == df_plot['p_Stop_N']]\n    if len(p_stop_matches) > 0:\n        node = p_stop_matches.iloc[0]\n        node_geom = node.geometry\n        if df_stop_nodes.crs != 'EPSG:4326':\n            node_gdf = gpd.GeoDataFrame([node], geometry='geometry', crs=df_stop_nodes.crs)\n            node_geom = node_gdf.to_crs('EPSG:4326').iloc[0].geometry\n\n        modes = p_stop_matches['MODE'].unique()\n        mode_names = [get_mode_name(m) for m in modes]\n\n        folium.Marker(\n            location=[node_geom.y, node_geom.x],\n            icon=folium.Icon(color='green', icon='circle', prefix='fa'),\n            popup=f\"Access Stop Node: {df_plot['p_Stop_N']}<br>Modes: {', '.join(mode_names)}\",\n            tooltip=f\"Network Node {df_plot['p_Stop_N']} (Access)\"\n        ).add_to(fg_snapped_stops)\n\n        snapped_nodes.append({\n            'type': 'access',\n            'lat': node_geom.y,\n            'lon': node_geom.x,\n            'node_id': df_plot['p_Stop_N']\n        })\n\n# Attraction Stop (Egress - where trip ends from network perspective)\nif pd.notna(df_plot['a_Stop_N']):\n    a_stop_matches = df_stop_nodes[df_stop_nodes['N'] == df_plot['a_Stop_N']]\n    if len(a_stop_matches) > 0:\n        node = a_stop_matches.iloc[0]\n        node_geom = node.geometry\n        if df_stop_nodes.crs != 'EPSG:4326':\n            node_gdf = gpd.GeoDataFrame([node], geometry='geometry', crs=df_stop_nodes.crs)\n            node_geom = node_gdf.to_crs('EPSG:4326').iloc[0].geometry\n\n        modes = a_stop_matches['MODE'].unique()\n        mode_names = [get_mode_name(m) for m in modes]\n\n        folium.Marker(\n            location=[node_geom.y, node_geom.x],\n            icon=folium.Icon(color='blue', icon='circle', prefix='fa'),\n            popup=f\"Egress Stop Node: {df_plot['a_Stop_N']}<br>Modes: {', '.join(mode_names)}\",\n            tooltip=f\"Network Node {df_plot['a_Stop_N']} (Egress)\"\n        ).add_to(fg_snapped_stops)\n\n        snapped_nodes.append({\n            'type': 'egress',\n            'lat': node_geom.y,\n            'lon': node_geom.x,\n            'node_id': df_plot['a_Stop_N']\n        })\n\n# ============================================================================\n# DRAW TRIP WITH SNAP CONNECTIONS\n# ============================================================================\n\n# 1. Access segment (Production Address → Snapped Access Stop)\nif len(snapped_nodes) > 0 and snapped_nodes[0]['type'] == 'access':\n    access_node = snapped_nodes[0]\n    access_mode = df_plot['Ac_Mode3_Model']\n    access_style = ACCESS_EGRESS_STYLES.get(access_mode, {'color': '#666666', 'weight': 3})\n\n    add_line_segment(\n        [[df_plot['p_lat'], df_plot['p_lon']],\n         [access_node['lat'], access_node['lon']]],\n        color=access_style['color'],\n        weight=access_style['weight'],\n        dash_array='8, 4',\n        label=f'Access: {access_mode}',\n        popup_text=f\"Access: {access_mode}<br>To Network Node: {access_node['node_id']}<br>Distance: {df_plot.get('access_dist', 'N/A'):.2f} mi\",\n        feature_group=fg_trip_lines\n    )\n\n    # Snap connection (Access Node → First Transit Stop)\n    if len(trip_sequence) > 0:\n        first_stop = trip_sequence[0]\n        add_line_segment(\n            [[access_node['lat'], access_node['lon']],\n             [first_stop['on_lat'], first_stop['on_lon']]],\n            color=SNAP_LINE_STYLE['color'],\n            weight=SNAP_LINE_STYLE['weight'],\n            dash_array=SNAP_LINE_STYLE['dash_array'],\n            label='Access Snap Connection',\n            popup_text=f\"Connection: Network Node → Surveyed Stop\",\n            feature_group=fg_snap_connections\n        )\n\n# 2. Transit segments and transfers\nfor i, segment in enumerate(trip_sequence):\n    add_stop_marker(\n        segment['on_lat'],\n        segment['on_lon'],\n        f\"Board: {segment['label']}<br>{segment['mode_name']}\",\n        segment['mode_num'],\n        fg_stops\n    )\n\n    base_weight = get_mode_weight(segment['mode_num'])\n    weight = int(base_weight * SURVEYED_TRIP_WEIGHT_MULTIPLIER) if segment['is_current'] else base_weight\n\n    add_line_segment(\n        [[segment['on_lat'], segment['on_lon']],\n         [segment['off_lat'], segment['off_lon']]],\n        color=get_mode_color(segment['mode_num']),\n        weight=weight,\n        dash_array=None,\n        label=f\"{segment['label']}: {segment['mode_name']}\",\n        popup_text=f\"{segment['label']}<br>{segment['mode_name']}\" +\n                   (\"<br><b>★ SURVEYED TRIP ★</b>\" if segment['is_current'] else \"\"),\n        feature_group=fg_trip_lines\n    )\n\n    add_stop_marker(\n        segment['off_lat'],\n        segment['off_lon'],\n        f\"Alight: {segment['label']}<br>{segment['mode_name']}\",\n        segment['mode_num'],\n        fg_stops\n    )\n\n    if i < len(trip_sequence) - 1:\n        next_segment = trip_sequence[i + 1]\n        add_line_segment(\n            [[segment['off_lat'], segment['off_lon']],\n             [next_segment['on_lat'], next_segment['on_lon']]],\n            color=TRANSFER_WALK_STYLE['color'],\n            weight=TRANSFER_WALK_STYLE['weight'],\n            dash_array='2, 6',\n            label='Transfer Walk',\n            popup_text='Walking between stops',\n            feature_group=fg_trip_lines\n        )\n\n# 3. Egress segment (Last Transit Stop → Snapped Egress Stop → Attraction Address)\nif len(trip_sequence) > 0:\n    last_stop = trip_sequence[-1]\n    egress_mode = df_plot['Eg_Mode3_Model']\n    egress_style = ACCESS_EGRESS_STYLES.get(egress_mode, {'color': '#666666', 'weight': 3})\n\n    # Find egress node\n    egress_node = next((n for n in snapped_nodes if n['type'] == 'egress'), None)\n\n    if egress_node:\n        # Snap connection (Last Transit Stop → Egress Node)\n        add_line_segment(\n            [[last_stop['off_lat'], last_stop['off_lon']],\n             [egress_node['lat'], egress_node['lon']]],\n            color=SNAP_LINE_STYLE['color'],\n            weight=SNAP_LINE_STYLE['weight'],\n            dash_array=SNAP_LINE_STYLE['dash_array'],\n            label='Egress Snap Connection',\n            popup_text=f\"Connection: Surveyed Stop → Network Node\",\n            feature_group=fg_snap_connections\n        )\n\n        # Egress walk (Egress Node → Attraction Address)\n        add_line_segment(\n            [[egress_node['lat'], egress_node['lon']],\n             [df_plot['a_lat'], df_plot['a_lon']]],\n            color=egress_style['color'],\n            weight=egress_style['weight'],\n            dash_array='8, 4',\n            label=f'Egress: {egress_mode}',\n            popup_text=f\"Egress: {egress_mode}<br>From Network Node: {egress_node['node_id']}<br>Distance: {df_plot.get('egress_dist', 'N/A'):.2f} mi\",\n            feature_group=fg_trip_lines\n        )\n\n# ============================================================================\n# ADD ADDRESS MARKERS\n# ============================================================================\nif pd.notna(df_plot['HOME_ADDRESS_LAT']) and pd.notna(df_plot['HOME_ADDRESS_LONG']):\n    folium.Marker(\n        location=[df_plot['HOME_ADDRESS_LAT'], df_plot['HOME_ADDRESS_LONG']],\n        icon=folium.Icon(color='red', icon='home', prefix='fa'),\n        popup='Home Address',\n        tooltip='Home'\n    ).add_to(fg_addresses)\n\nif pd.notna(df_plot['p_lat']) and pd.notna(df_plot['p_lon']):\n    folium.Marker(\n        location=[df_plot['p_lat'], df_plot['p_lon']],\n        icon=folium.Icon(color='darkgreen', icon='play', prefix='fa'),\n        popup=f\"Production Address<br>TAZ: {df_plot['p_TAZID']}<br>Purpose: {df_plot['Purp5_text']}\",\n        tooltip='Production (Trip Start)'\n    ).add_to(fg_addresses)\n\nif pd.notna(df_plot['a_lat']) and pd.notna(df_plot['a_lon']):\n    folium.Marker(\n        location=[df_plot['a_lat'], df_plot['a_lon']],\n        icon=folium.Icon(color='darkblue', icon='stop', prefix='fa'),\n        popup=f\"Attraction Address<br>TAZ: {df_plot['a_TAZID']}<br>Purpose: {df_plot['Purp5_text']}\",\n        tooltip='Attraction (Trip End)'\n    ).add_to(fg_addresses)\n\n# ============================================================================\n# ADD LAYERS\n# ============================================================================\nfg_taz.add_to(m)\nfg_all_nodes.add_to(m)  # Add all network nodes layer\nfg_trip_lines.add_to(m)\nfg_snap_connections.add_to(m)\nfg_stops.add_to(m)\nfg_snapped_stops.add_to(m)  # Snapped nodes on top\nfg_addresses.add_to(m)\n\nfolium.LayerControl(collapsed=False).add_to(m)\n\n# ============================================================================\n# ADD TRIP SUMMARY\n# ============================================================================\nmode_sequence_html = \"\"\nfor i, seg in enumerate(trip_sequence, 1):\n    color = get_mode_color(seg['mode_num'])\n    star = \" ★\" if seg['is_current'] else \"\"\n    mode_sequence_html += f'{i}. <span style=\"color:{color}\">●</span> {seg[\"mode_name\"]}{star}<br>'\n\ntrip_summary = f\"\"\"\n<div style=\"position: fixed;\n     top: 10px; left: 60px; width: 340px;\n     background-color: white; border:2px solid grey; z-index:9999;\n     font-size:13px; padding: 10px; font-family: Arial, sans-serif;\">\n<b style=\"font-size: 15px;\">Trip ID: {df_plot['ID']}</b><br>\n<hr style=\"margin: 5px 0;\">\n<b>Trip Details:</b><br>\nDirection: {df_plot['PA_AP']} (P → A)<br>\nPurpose: {df_plot['Purp5_text']}<br>\nPeriod: {df_plot['Period']}<br>\nLinked Mode: {df_plot['Linked_Mode_txt']}<br>\nTotal Transfers: {df_plot['Total_Xfer']}<br>\n<hr style=\"margin: 5px 0;\">\n<b>Access/Egress:</b><br>\nAccess: {df_plot['Ac_Mode3_Model']} ({df_plot.get('access_dist', 'N/A'):.2f} mi)<br>\nEgress: {df_plot['Eg_Mode3_Model']} ({df_plot.get('egress_dist', 'N/A'):.2f} mi)<br>\n<hr style=\"margin: 5px 0;\">\n<b>Transit Sequence:</b><br>\n{mode_sequence_html}\n<hr style=\"margin: 5px 0;\">\n<small>\n<span style=\"color:{SNAP_LINE_STYLE['color']}\">- - -</span> = Network snap connection<br>\n<span style=\"color:{TRANSFER_WALK_STYLE['color']}\">⋯⋯</span> = Transfer walk<br>\n<span style=\"color:#898a8d\">▬ ▬</span> = Access/Egress walk\n</small>\n</div>\n\"\"\"\nm.get_root().html.add_child(folium.Element(trip_summary))\n\nm\n```\n:::\n\n\n# Export\n\n## Save OBS data with CRT Links\n\n::: {#72f70860 .cell execution_count=27}\n``` {.python .cell-code}\n# Create output directory if it doesn't exist\noutput_dir = Path(\"_output\")\noutput_dir.mkdir(parents=True, exist_ok=True)\n\n# Export to CSV\ndf_obs_linked.to_csv(\n    output_dir / \"UTA_OBS_2024_Linked_FactorAdjusted_CRT.csv\",\n    index=False\n)\n\nprint(f\"Exported {len(df_obs_linked)} records\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nExported 12020 records\n```\n:::\n:::\n\n\n::: {.callout-tip title=\"Download the output file:\"}\n[UTA_OBS_2024_Linked_FactorAdjusted_CRT.csv](./_output/UTA_OBS_2024_Linked_FactorAdjusted_CRT.csv)\n:::\n\n",
    "supporting": [
      "1-crt-trip-distances_files\\figure-html"
    ],
    "filters": [],
    "includes": {
      "include-in-header": [
        "<script src=\"https://cdn.jsdelivr.net/npm/requirejs@2.3.6/require.min.js\" integrity=\"sha384-c9c+LnTbwQ3aujuU7ULEPVvgLs+Fn6fJUvIGTsuu1ZcCf11fiEubah0ttpca4ntM sha384-6V1/AdqZRWk1KAlWbKBlGhN7VG4iE/yAZcO6NZPMF8od0vukrvr0tg4qY6NSrItx\" crossorigin=\"anonymous\"></script>\n<script src=\"https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js\" integrity=\"sha384-ZvpUoO/+PpLXR1lu4jmpXWu80pZlYUAfxl5NsBMWOEPSjUn/6Z/hRTt8+pR6L4N2\" crossorigin=\"anonymous\" data-relocate-top=\"true\"></script>\n<script type=\"application/javascript\">define('jquery', [],function() {return window.jQuery;})</script>\n"
      ]
    }
  }
}